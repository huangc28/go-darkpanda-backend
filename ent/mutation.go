// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/huangc28/go-darkpanda-backend/ent/group"
	"github.com/huangc28/go-darkpanda-backend/ent/groupusers"
	"github.com/huangc28/go-darkpanda-backend/ent/inquiry"
	"github.com/huangc28/go-darkpanda-backend/ent/service"
	"github.com/huangc28/go-darkpanda-backend/ent/user"
	"github.com/huangc28/go-darkpanda-backend/ent/userrefcodes"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGroup        = "Group"
	TypeGroupUsers   = "GroupUsers"
	TypeInquiry      = "Inquiry"
	TypeService      = "Service"
	TypeUser         = "User"
	TypeUserRefCodes = "UserRefCodes"
)

// GroupMutation represents an operation that mutate the Groups
// nodes in the graph.
type GroupMutation struct {
	config
	op            Op
	typ           string
	id            *int
	group_type    *group.GroupType
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Group, error)
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows to manage the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for $n.Name.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the id field of the mutation.
func withGroupID(id int) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGroupType sets the group_type field.
func (m *GroupMutation) SetGroupType(gt group.GroupType) {
	m.group_type = &gt
}

// GroupType returns the group_type value in the mutation.
func (m *GroupMutation) GroupType() (r group.GroupType, exists bool) {
	v := m.group_type
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupType returns the old group_type value of the Group.
// If the Group object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GroupMutation) OldGroupType(ctx context.Context) (v group.GroupType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGroupType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGroupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupType: %w", err)
	}
	return oldValue.GroupType, nil
}

// ResetGroupType reset all changes of the "group_type" field.
func (m *GroupMutation) ResetGroupType() {
	m.group_type = nil
}

// AddUserIDs adds the users edge to User by ids.
func (m *GroupMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the users edge to User by ids.
func (m *GroupMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *GroupMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *GroupMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *GroupMutation) ResetUsers() {
	m.users = nil
	m.removedusers = nil
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.group_type != nil {
		fields = append(fields, group.FieldGroupType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldGroupType:
		return m.GroupType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldGroupType:
		return m.OldGroupType(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldGroupType:
		v, ok := value.(group.GroupType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupType(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldGroupType:
		m.ResetGroupType()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, group.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// GroupUsersMutation represents an operation that mutate the GroupUsersSlice
// nodes in the graph.
type GroupUsersMutation struct {
	config
	op            Op
	typ           string
	id            *int
	auth_type     *groupusers.AuthType
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GroupUsers, error)
}

var _ ent.Mutation = (*GroupUsersMutation)(nil)

// groupusersOption allows to manage the mutation configuration using functional options.
type groupusersOption func(*GroupUsersMutation)

// newGroupUsersMutation creates new mutation for $n.Name.
func newGroupUsersMutation(c config, op Op, opts ...groupusersOption) *GroupUsersMutation {
	m := &GroupUsersMutation{
		config:        c,
		op:            op,
		typ:           TypeGroupUsers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupUsersID sets the id field of the mutation.
func withGroupUsersID(id int) groupusersOption {
	return func(m *GroupUsersMutation) {
		var (
			err   error
			once  sync.Once
			value *GroupUsers
		)
		m.oldValue = func(ctx context.Context) (*GroupUsers, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GroupUsers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroupUsers sets the old GroupUsers of the mutation.
func withGroupUsers(node *GroupUsers) groupusersOption {
	return func(m *GroupUsersMutation) {
		m.oldValue = func(context.Context) (*GroupUsers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupUsersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupUsersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GroupUsersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAuthType sets the auth_type field.
func (m *GroupUsersMutation) SetAuthType(gt groupusers.AuthType) {
	m.auth_type = &gt
}

// AuthType returns the auth_type value in the mutation.
func (m *GroupUsersMutation) AuthType() (r groupusers.AuthType, exists bool) {
	v := m.auth_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthType returns the old auth_type value of the GroupUsers.
// If the GroupUsers object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GroupUsersMutation) OldAuthType(ctx context.Context) (v groupusers.AuthType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthType: %w", err)
	}
	return oldValue.AuthType, nil
}

// ResetAuthType reset all changes of the "auth_type" field.
func (m *GroupUsersMutation) ResetAuthType() {
	m.auth_type = nil
}

// Op returns the operation name.
func (m *GroupUsersMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GroupUsers).
func (m *GroupUsersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GroupUsersMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.auth_type != nil {
		fields = append(fields, groupusers.FieldAuthType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GroupUsersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case groupusers.FieldAuthType:
		return m.AuthType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GroupUsersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case groupusers.FieldAuthType:
		return m.OldAuthType(ctx)
	}
	return nil, fmt.Errorf("unknown GroupUsers field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroupUsersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case groupusers.FieldAuthType:
		v, ok := value.(groupusers.AuthType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthType(v)
		return nil
	}
	return fmt.Errorf("unknown GroupUsers field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GroupUsersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GroupUsersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GroupUsersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GroupUsers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GroupUsersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GroupUsersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupUsersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GroupUsers nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GroupUsersMutation) ResetField(name string) error {
	switch name {
	case groupusers.FieldAuthType:
		m.ResetAuthType()
		return nil
	}
	return fmt.Errorf("unknown GroupUsers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GroupUsersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GroupUsersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GroupUsersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GroupUsersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GroupUsersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GroupUsersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GroupUsersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GroupUsers unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GroupUsersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GroupUsers edge %s", name)
}

// InquiryMutation represents an operation that mutate the Inquiries
// nodes in the graph.
type InquiryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	budget         *float32
	addbudget      *float32
	service_type   *inquiry.ServiceType
	inquiry_status *inquiry.InquiryStatus
	clearedFields  map[string]struct{}
	users          *int
	clearedusers   bool
	done           bool
	oldValue       func(context.Context) (*Inquiry, error)
}

var _ ent.Mutation = (*InquiryMutation)(nil)

// inquiryOption allows to manage the mutation configuration using functional options.
type inquiryOption func(*InquiryMutation)

// newInquiryMutation creates new mutation for $n.Name.
func newInquiryMutation(c config, op Op, opts ...inquiryOption) *InquiryMutation {
	m := &InquiryMutation{
		config:        c,
		op:            op,
		typ:           TypeInquiry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInquiryID sets the id field of the mutation.
func withInquiryID(id int) inquiryOption {
	return func(m *InquiryMutation) {
		var (
			err   error
			once  sync.Once
			value *Inquiry
		)
		m.oldValue = func(ctx context.Context) (*Inquiry, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inquiry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInquiry sets the old Inquiry of the mutation.
func withInquiry(node *Inquiry) inquiryOption {
	return func(m *InquiryMutation) {
		m.oldValue = func(context.Context) (*Inquiry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InquiryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InquiryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *InquiryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBudget sets the budget field.
func (m *InquiryMutation) SetBudget(f float32) {
	m.budget = &f
	m.addbudget = nil
}

// Budget returns the budget value in the mutation.
func (m *InquiryMutation) Budget() (r float32, exists bool) {
	v := m.budget
	if v == nil {
		return
	}
	return *v, true
}

// OldBudget returns the old budget value of the Inquiry.
// If the Inquiry object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InquiryMutation) OldBudget(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBudget is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBudget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudget: %w", err)
	}
	return oldValue.Budget, nil
}

// AddBudget adds f to budget.
func (m *InquiryMutation) AddBudget(f float32) {
	if m.addbudget != nil {
		*m.addbudget += f
	} else {
		m.addbudget = &f
	}
}

// AddedBudget returns the value that was added to the budget field in this mutation.
func (m *InquiryMutation) AddedBudget() (r float32, exists bool) {
	v := m.addbudget
	if v == nil {
		return
	}
	return *v, true
}

// ResetBudget reset all changes of the "budget" field.
func (m *InquiryMutation) ResetBudget() {
	m.budget = nil
	m.addbudget = nil
}

// SetServiceType sets the service_type field.
func (m *InquiryMutation) SetServiceType(it inquiry.ServiceType) {
	m.service_type = &it
}

// ServiceType returns the service_type value in the mutation.
func (m *InquiryMutation) ServiceType() (r inquiry.ServiceType, exists bool) {
	v := m.service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceType returns the old service_type value of the Inquiry.
// If the Inquiry object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InquiryMutation) OldServiceType(ctx context.Context) (v inquiry.ServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceType: %w", err)
	}
	return oldValue.ServiceType, nil
}

// ResetServiceType reset all changes of the "service_type" field.
func (m *InquiryMutation) ResetServiceType() {
	m.service_type = nil
}

// SetInquiryStatus sets the inquiry_status field.
func (m *InquiryMutation) SetInquiryStatus(is inquiry.InquiryStatus) {
	m.inquiry_status = &is
}

// InquiryStatus returns the inquiry_status value in the mutation.
func (m *InquiryMutation) InquiryStatus() (r inquiry.InquiryStatus, exists bool) {
	v := m.inquiry_status
	if v == nil {
		return
	}
	return *v, true
}

// OldInquiryStatus returns the old inquiry_status value of the Inquiry.
// If the Inquiry object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *InquiryMutation) OldInquiryStatus(ctx context.Context) (v inquiry.InquiryStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInquiryStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInquiryStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInquiryStatus: %w", err)
	}
	return oldValue.InquiryStatus, nil
}

// ResetInquiryStatus reset all changes of the "inquiry_status" field.
func (m *InquiryMutation) ResetInquiryStatus() {
	m.inquiry_status = nil
}

// SetUsersID sets the users edge to User by id.
func (m *InquiryMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the users edge to User.
func (m *InquiryMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared returns if the edge users was cleared.
func (m *InquiryMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the users id in the mutation.
func (m *InquiryMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the users ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *InquiryMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *InquiryMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Op returns the operation name.
func (m *InquiryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inquiry).
func (m *InquiryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *InquiryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.budget != nil {
		fields = append(fields, inquiry.FieldBudget)
	}
	if m.service_type != nil {
		fields = append(fields, inquiry.FieldServiceType)
	}
	if m.inquiry_status != nil {
		fields = append(fields, inquiry.FieldInquiryStatus)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *InquiryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inquiry.FieldBudget:
		return m.Budget()
	case inquiry.FieldServiceType:
		return m.ServiceType()
	case inquiry.FieldInquiryStatus:
		return m.InquiryStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *InquiryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inquiry.FieldBudget:
		return m.OldBudget(ctx)
	case inquiry.FieldServiceType:
		return m.OldServiceType(ctx)
	case inquiry.FieldInquiryStatus:
		return m.OldInquiryStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Inquiry field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InquiryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inquiry.FieldBudget:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudget(v)
		return nil
	case inquiry.FieldServiceType:
		v, ok := value.(inquiry.ServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceType(v)
		return nil
	case inquiry.FieldInquiryStatus:
		v, ok := value.(inquiry.InquiryStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInquiryStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Inquiry field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *InquiryMutation) AddedFields() []string {
	var fields []string
	if m.addbudget != nil {
		fields = append(fields, inquiry.FieldBudget)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *InquiryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inquiry.FieldBudget:
		return m.AddedBudget()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *InquiryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inquiry.FieldBudget:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudget(v)
		return nil
	}
	return fmt.Errorf("unknown Inquiry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *InquiryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *InquiryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *InquiryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Inquiry nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *InquiryMutation) ResetField(name string) error {
	switch name {
	case inquiry.FieldBudget:
		m.ResetBudget()
		return nil
	case inquiry.FieldServiceType:
		m.ResetServiceType()
		return nil
	case inquiry.FieldInquiryStatus:
		m.ResetInquiryStatus()
		return nil
	}
	return fmt.Errorf("unknown Inquiry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *InquiryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, inquiry.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *InquiryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inquiry.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *InquiryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *InquiryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *InquiryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, inquiry.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *InquiryMutation) EdgeCleared(name string) bool {
	switch name {
	case inquiry.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *InquiryMutation) ClearEdge(name string) error {
	switch name {
	case inquiry.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown Inquiry unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *InquiryMutation) ResetEdge(name string) error {
	switch name {
	case inquiry.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Inquiry edge %s", name)
}

// ServiceMutation represents an operation that mutate the Services
// nodes in the graph.
type ServiceMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	uuid                    *uuid.UUID
	price                   *float32
	addprice                *float32
	duration                *int
	addduration             *int
	appointment_time        *time.Time
	lng                     *float64
	addlng                  *float64
	lat                     *float64
	addlat                  *float64
	service_type            *service.ServiceType
	service_status          *service.ServiceStatus
	girl_ready              *bool
	man_ready               *bool
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	customer                *int
	clearedcustomer         bool
	service_provider        *int
	clearedservice_provider bool
	done                    bool
	oldValue                func(context.Context) (*Service, error)
}

var _ ent.Mutation = (*ServiceMutation)(nil)

// serviceOption allows to manage the mutation configuration using functional options.
type serviceOption func(*ServiceMutation)

// newServiceMutation creates new mutation for $n.Name.
func newServiceMutation(c config, op Op, opts ...serviceOption) *ServiceMutation {
	m := &ServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceID sets the id field of the mutation.
func withServiceID(id int) serviceOption {
	return func(m *ServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *Service
		)
		m.oldValue = func(ctx context.Context) (*Service, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Service.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withService sets the old Service of the mutation.
func withService(node *Service) serviceOption {
	return func(m *ServiceMutation) {
		m.oldValue = func(context.Context) (*Service, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ServiceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUUID sets the uuid field.
func (m *ServiceMutation) SetUUID(u uuid.UUID) {
	m.uuid = &u
}

// UUID returns the uuid value in the mutation.
func (m *ServiceMutation) UUID() (r uuid.UUID, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old uuid value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUUID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID reset all changes of the "uuid" field.
func (m *ServiceMutation) ResetUUID() {
	m.uuid = nil
}

// SetPrice sets the price field.
func (m *ServiceMutation) SetPrice(f float32) {
	m.price = &f
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *ServiceMutation) Price() (r float32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldPrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to price.
func (m *ServiceMutation) AddPrice(f float32) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *ServiceMutation) AddedPrice() (r float32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *ServiceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDuration sets the duration field.
func (m *ServiceMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the duration value in the mutation.
func (m *ServiceMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old duration value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to duration.
func (m *ServiceMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the duration field in this mutation.
func (m *ServiceMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration reset all changes of the "duration" field.
func (m *ServiceMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetAppointmentTime sets the appointment_time field.
func (m *ServiceMutation) SetAppointmentTime(t time.Time) {
	m.appointment_time = &t
}

// AppointmentTime returns the appointment_time value in the mutation.
func (m *ServiceMutation) AppointmentTime() (r time.Time, exists bool) {
	v := m.appointment_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentTime returns the old appointment_time value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldAppointmentTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAppointmentTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAppointmentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentTime: %w", err)
	}
	return oldValue.AppointmentTime, nil
}

// ResetAppointmentTime reset all changes of the "appointment_time" field.
func (m *ServiceMutation) ResetAppointmentTime() {
	m.appointment_time = nil
}

// SetLng sets the lng field.
func (m *ServiceMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the lng value in the mutation.
func (m *ServiceMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old lng value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLng is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to lng.
func (m *ServiceMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the lng field in this mutation.
func (m *ServiceMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng reset all changes of the "lng" field.
func (m *ServiceMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetLat sets the lat field.
func (m *ServiceMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the lat value in the mutation.
func (m *ServiceMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old lat value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLat is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to lat.
func (m *ServiceMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the lat field in this mutation.
func (m *ServiceMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat reset all changes of the "lat" field.
func (m *ServiceMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetServiceType sets the service_type field.
func (m *ServiceMutation) SetServiceType(st service.ServiceType) {
	m.service_type = &st
}

// ServiceType returns the service_type value in the mutation.
func (m *ServiceMutation) ServiceType() (r service.ServiceType, exists bool) {
	v := m.service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceType returns the old service_type value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldServiceType(ctx context.Context) (v service.ServiceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceType: %w", err)
	}
	return oldValue.ServiceType, nil
}

// ResetServiceType reset all changes of the "service_type" field.
func (m *ServiceMutation) ResetServiceType() {
	m.service_type = nil
}

// SetServiceStatus sets the service_status field.
func (m *ServiceMutation) SetServiceStatus(ss service.ServiceStatus) {
	m.service_status = &ss
}

// ServiceStatus returns the service_status value in the mutation.
func (m *ServiceMutation) ServiceStatus() (r service.ServiceStatus, exists bool) {
	v := m.service_status
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceStatus returns the old service_status value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldServiceStatus(ctx context.Context) (v service.ServiceStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldServiceStatus is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldServiceStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceStatus: %w", err)
	}
	return oldValue.ServiceStatus, nil
}

// ClearServiceStatus clears the value of service_status.
func (m *ServiceMutation) ClearServiceStatus() {
	m.service_status = nil
	m.clearedFields[service.FieldServiceStatus] = struct{}{}
}

// ServiceStatusCleared returns if the field service_status was cleared in this mutation.
func (m *ServiceMutation) ServiceStatusCleared() bool {
	_, ok := m.clearedFields[service.FieldServiceStatus]
	return ok
}

// ResetServiceStatus reset all changes of the "service_status" field.
func (m *ServiceMutation) ResetServiceStatus() {
	m.service_status = nil
	delete(m.clearedFields, service.FieldServiceStatus)
}

// SetGirlReady sets the girl_ready field.
func (m *ServiceMutation) SetGirlReady(b bool) {
	m.girl_ready = &b
}

// GirlReady returns the girl_ready value in the mutation.
func (m *ServiceMutation) GirlReady() (r bool, exists bool) {
	v := m.girl_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldGirlReady returns the old girl_ready value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldGirlReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGirlReady is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGirlReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGirlReady: %w", err)
	}
	return oldValue.GirlReady, nil
}

// ResetGirlReady reset all changes of the "girl_ready" field.
func (m *ServiceMutation) ResetGirlReady() {
	m.girl_ready = nil
}

// SetManReady sets the man_ready field.
func (m *ServiceMutation) SetManReady(b bool) {
	m.man_ready = &b
}

// ManReady returns the man_ready value in the mutation.
func (m *ServiceMutation) ManReady() (r bool, exists bool) {
	v := m.man_ready
	if v == nil {
		return
	}
	return *v, true
}

// OldManReady returns the old man_ready value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldManReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldManReady is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldManReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManReady: %w", err)
	}
	return oldValue.ManReady, nil
}

// ResetManReady reset all changes of the "man_ready" field.
func (m *ServiceMutation) ResetManReady() {
	m.man_ready = nil
}

// SetCreatedAt sets the created_at field.
func (m *ServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *ServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *ServiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *ServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *ServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the Service.
// If the Service object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *ServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCustomerID sets the customer edge to User by id.
func (m *ServiceMutation) SetCustomerID(id int) {
	m.customer = &id
}

// ClearCustomer clears the customer edge to User.
func (m *ServiceMutation) ClearCustomer() {
	m.clearedcustomer = true
}

// CustomerCleared returns if the edge customer was cleared.
func (m *ServiceMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerID returns the customer id in the mutation.
func (m *ServiceMutation) CustomerID() (id int, exists bool) {
	if m.customer != nil {
		return *m.customer, true
	}
	return
}

// CustomerIDs returns the customer ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) CustomerIDs() (ids []int) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer reset all changes of the "customer" edge.
func (m *ServiceMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// SetServiceProviderID sets the service_provider edge to User by id.
func (m *ServiceMutation) SetServiceProviderID(id int) {
	m.service_provider = &id
}

// ClearServiceProvider clears the service_provider edge to User.
func (m *ServiceMutation) ClearServiceProvider() {
	m.clearedservice_provider = true
}

// ServiceProviderCleared returns if the edge service_provider was cleared.
func (m *ServiceMutation) ServiceProviderCleared() bool {
	return m.clearedservice_provider
}

// ServiceProviderID returns the service_provider id in the mutation.
func (m *ServiceMutation) ServiceProviderID() (id int, exists bool) {
	if m.service_provider != nil {
		return *m.service_provider, true
	}
	return
}

// ServiceProviderIDs returns the service_provider ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ServiceProviderID instead. It exists only for internal usage by the builders.
func (m *ServiceMutation) ServiceProviderIDs() (ids []int) {
	if id := m.service_provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceProvider reset all changes of the "service_provider" edge.
func (m *ServiceMutation) ResetServiceProvider() {
	m.service_provider = nil
	m.clearedservice_provider = false
}

// Op returns the operation name.
func (m *ServiceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Service).
func (m *ServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ServiceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.uuid != nil {
		fields = append(fields, service.FieldUUID)
	}
	if m.price != nil {
		fields = append(fields, service.FieldPrice)
	}
	if m.duration != nil {
		fields = append(fields, service.FieldDuration)
	}
	if m.appointment_time != nil {
		fields = append(fields, service.FieldAppointmentTime)
	}
	if m.lng != nil {
		fields = append(fields, service.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, service.FieldLat)
	}
	if m.service_type != nil {
		fields = append(fields, service.FieldServiceType)
	}
	if m.service_status != nil {
		fields = append(fields, service.FieldServiceStatus)
	}
	if m.girl_ready != nil {
		fields = append(fields, service.FieldGirlReady)
	}
	if m.man_ready != nil {
		fields = append(fields, service.FieldManReady)
	}
	if m.created_at != nil {
		fields = append(fields, service.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, service.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case service.FieldUUID:
		return m.UUID()
	case service.FieldPrice:
		return m.Price()
	case service.FieldDuration:
		return m.Duration()
	case service.FieldAppointmentTime:
		return m.AppointmentTime()
	case service.FieldLng:
		return m.Lng()
	case service.FieldLat:
		return m.Lat()
	case service.FieldServiceType:
		return m.ServiceType()
	case service.FieldServiceStatus:
		return m.ServiceStatus()
	case service.FieldGirlReady:
		return m.GirlReady()
	case service.FieldManReady:
		return m.ManReady()
	case service.FieldCreatedAt:
		return m.CreatedAt()
	case service.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case service.FieldUUID:
		return m.OldUUID(ctx)
	case service.FieldPrice:
		return m.OldPrice(ctx)
	case service.FieldDuration:
		return m.OldDuration(ctx)
	case service.FieldAppointmentTime:
		return m.OldAppointmentTime(ctx)
	case service.FieldLng:
		return m.OldLng(ctx)
	case service.FieldLat:
		return m.OldLat(ctx)
	case service.FieldServiceType:
		return m.OldServiceType(ctx)
	case service.FieldServiceStatus:
		return m.OldServiceStatus(ctx)
	case service.FieldGirlReady:
		return m.OldGirlReady(ctx)
	case service.FieldManReady:
		return m.OldManReady(ctx)
	case service.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case service.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Service field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case service.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case service.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case service.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case service.FieldAppointmentTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentTime(v)
		return nil
	case service.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case service.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case service.FieldServiceType:
		v, ok := value.(service.ServiceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceType(v)
		return nil
	case service.FieldServiceStatus:
		v, ok := value.(service.ServiceStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceStatus(v)
		return nil
	case service.FieldGirlReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGirlReady(v)
		return nil
	case service.FieldManReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManReady(v)
		return nil
	case service.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case service.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ServiceMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, service.FieldPrice)
	}
	if m.addduration != nil {
		fields = append(fields, service.FieldDuration)
	}
	if m.addlng != nil {
		fields = append(fields, service.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, service.FieldLat)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case service.FieldPrice:
		return m.AddedPrice()
	case service.FieldDuration:
		return m.AddedDuration()
	case service.FieldLng:
		return m.AddedLng()
	case service.FieldLat:
		return m.AddedLat()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case service.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case service.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	case service.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case service.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	}
	return fmt.Errorf("unknown Service numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(service.FieldServiceStatus) {
		fields = append(fields, service.FieldServiceStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceMutation) ClearField(name string) error {
	switch name {
	case service.FieldServiceStatus:
		m.ClearServiceStatus()
		return nil
	}
	return fmt.Errorf("unknown Service nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ServiceMutation) ResetField(name string) error {
	switch name {
	case service.FieldUUID:
		m.ResetUUID()
		return nil
	case service.FieldPrice:
		m.ResetPrice()
		return nil
	case service.FieldDuration:
		m.ResetDuration()
		return nil
	case service.FieldAppointmentTime:
		m.ResetAppointmentTime()
		return nil
	case service.FieldLng:
		m.ResetLng()
		return nil
	case service.FieldLat:
		m.ResetLat()
		return nil
	case service.FieldServiceType:
		m.ResetServiceType()
		return nil
	case service.FieldServiceStatus:
		m.ResetServiceStatus()
		return nil
	case service.FieldGirlReady:
		m.ResetGirlReady()
		return nil
	case service.FieldManReady:
		m.ResetManReady()
		return nil
	case service.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case service.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Service field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.customer != nil {
		edges = append(edges, service.EdgeCustomer)
	}
	if m.service_provider != nil {
		edges = append(edges, service.EdgeServiceProvider)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case service.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case service.EdgeServiceProvider:
		if id := m.service_provider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcustomer {
		edges = append(edges, service.EdgeCustomer)
	}
	if m.clearedservice_provider {
		edges = append(edges, service.EdgeServiceProvider)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case service.EdgeCustomer:
		return m.clearedcustomer
	case service.EdgeServiceProvider:
		return m.clearedservice_provider
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ServiceMutation) ClearEdge(name string) error {
	switch name {
	case service.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case service.EdgeServiceProvider:
		m.ClearServiceProvider()
		return nil
	}
	return fmt.Errorf("unknown Service unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ServiceMutation) ResetEdge(name string) error {
	switch name {
	case service.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case service.EdgeServiceProvider:
		m.ResetServiceProvider()
		return nil
	}
	return fmt.Errorf("unknown Service edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	username                *string
	phone_verified          *bool
	auth_sms_code           *int16
	addauth_sms_code        *int16
	gender                  *user.Gender
	premium_kind            *user.PremiumKind
	premium_expiry_date     *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	refcode_invitor         map[int]struct{}
	removedrefcode_invitor  map[int]struct{}
	userrefcodes            map[int]struct{}
	removeduserrefcodes     map[int]struct{}
	inquiry                 *int
	clearedinquiry          bool
	service_customer        map[int]struct{}
	removedservice_customer map[int]struct{}
	service_provider        map[int]struct{}
	removedservice_provider map[int]struct{}
	groups                  map[int]struct{}
	removedgroups           map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUsername sets the username field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the username value in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old username value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername reset all changes of the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPhoneVerified sets the phone_verified field.
func (m *UserMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the phone_verified value in the mutation.
func (m *UserMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old phone_verified value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneVerified is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ResetPhoneVerified reset all changes of the "phone_verified" field.
func (m *UserMutation) ResetPhoneVerified() {
	m.phone_verified = nil
}

// SetAuthSmsCode sets the auth_sms_code field.
func (m *UserMutation) SetAuthSmsCode(i int16) {
	m.auth_sms_code = &i
	m.addauth_sms_code = nil
}

// AuthSmsCode returns the auth_sms_code value in the mutation.
func (m *UserMutation) AuthSmsCode() (r int16, exists bool) {
	v := m.auth_sms_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthSmsCode returns the old auth_sms_code value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAuthSmsCode(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthSmsCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthSmsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthSmsCode: %w", err)
	}
	return oldValue.AuthSmsCode, nil
}

// AddAuthSmsCode adds i to auth_sms_code.
func (m *UserMutation) AddAuthSmsCode(i int16) {
	if m.addauth_sms_code != nil {
		*m.addauth_sms_code += i
	} else {
		m.addauth_sms_code = &i
	}
}

// AddedAuthSmsCode returns the value that was added to the auth_sms_code field in this mutation.
func (m *UserMutation) AddedAuthSmsCode() (r int16, exists bool) {
	v := m.addauth_sms_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearAuthSmsCode clears the value of auth_sms_code.
func (m *UserMutation) ClearAuthSmsCode() {
	m.auth_sms_code = nil
	m.addauth_sms_code = nil
	m.clearedFields[user.FieldAuthSmsCode] = struct{}{}
}

// AuthSmsCodeCleared returns if the field auth_sms_code was cleared in this mutation.
func (m *UserMutation) AuthSmsCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldAuthSmsCode]
	return ok
}

// ResetAuthSmsCode reset all changes of the "auth_sms_code" field.
func (m *UserMutation) ResetAuthSmsCode() {
	m.auth_sms_code = nil
	m.addauth_sms_code = nil
	delete(m.clearedFields, user.FieldAuthSmsCode)
}

// SetGender sets the gender field.
func (m *UserMutation) SetGender(u user.Gender) {
	m.gender = &u
}

// Gender returns the gender value in the mutation.
func (m *UserMutation) Gender() (r user.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v user.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender reset all changes of the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
}

// SetPremiumKind sets the premium_kind field.
func (m *UserMutation) SetPremiumKind(uk user.PremiumKind) {
	m.premium_kind = &uk
}

// PremiumKind returns the premium_kind value in the mutation.
func (m *UserMutation) PremiumKind() (r user.PremiumKind, exists bool) {
	v := m.premium_kind
	if v == nil {
		return
	}
	return *v, true
}

// OldPremiumKind returns the old premium_kind value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPremiumKind(ctx context.Context) (v user.PremiumKind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPremiumKind is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPremiumKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPremiumKind: %w", err)
	}
	return oldValue.PremiumKind, nil
}

// ResetPremiumKind reset all changes of the "premium_kind" field.
func (m *UserMutation) ResetPremiumKind() {
	m.premium_kind = nil
}

// SetPremiumExpiryDate sets the premium_expiry_date field.
func (m *UserMutation) SetPremiumExpiryDate(t time.Time) {
	m.premium_expiry_date = &t
}

// PremiumExpiryDate returns the premium_expiry_date value in the mutation.
func (m *UserMutation) PremiumExpiryDate() (r time.Time, exists bool) {
	v := m.premium_expiry_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPremiumExpiryDate returns the old premium_expiry_date value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPremiumExpiryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPremiumExpiryDate is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPremiumExpiryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPremiumExpiryDate: %w", err)
	}
	return oldValue.PremiumExpiryDate, nil
}

// ResetPremiumExpiryDate reset all changes of the "premium_expiry_date" field.
func (m *UserMutation) ResetPremiumExpiryDate() {
	m.premium_expiry_date = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddRefcodeInvitorIDs adds the refcode_invitor edge to UserRefCodes by ids.
func (m *UserMutation) AddRefcodeInvitorIDs(ids ...int) {
	if m.refcode_invitor == nil {
		m.refcode_invitor = make(map[int]struct{})
	}
	for i := range ids {
		m.refcode_invitor[ids[i]] = struct{}{}
	}
}

// RemoveRefcodeInvitorIDs removes the refcode_invitor edge to UserRefCodes by ids.
func (m *UserMutation) RemoveRefcodeInvitorIDs(ids ...int) {
	if m.removedrefcode_invitor == nil {
		m.removedrefcode_invitor = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrefcode_invitor[ids[i]] = struct{}{}
	}
}

// RemovedRefcodeInvitor returns the removed ids of refcode_invitor.
func (m *UserMutation) RemovedRefcodeInvitorIDs() (ids []int) {
	for id := range m.removedrefcode_invitor {
		ids = append(ids, id)
	}
	return
}

// RefcodeInvitorIDs returns the refcode_invitor ids in the mutation.
func (m *UserMutation) RefcodeInvitorIDs() (ids []int) {
	for id := range m.refcode_invitor {
		ids = append(ids, id)
	}
	return
}

// ResetRefcodeInvitor reset all changes of the "refcode_invitor" edge.
func (m *UserMutation) ResetRefcodeInvitor() {
	m.refcode_invitor = nil
	m.removedrefcode_invitor = nil
}

// AddUserrefcodeIDs adds the userrefcodes edge to UserRefCodes by ids.
func (m *UserMutation) AddUserrefcodeIDs(ids ...int) {
	if m.userrefcodes == nil {
		m.userrefcodes = make(map[int]struct{})
	}
	for i := range ids {
		m.userrefcodes[ids[i]] = struct{}{}
	}
}

// RemoveUserrefcodeIDs removes the userrefcodes edge to UserRefCodes by ids.
func (m *UserMutation) RemoveUserrefcodeIDs(ids ...int) {
	if m.removeduserrefcodes == nil {
		m.removeduserrefcodes = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduserrefcodes[ids[i]] = struct{}{}
	}
}

// RemovedUserrefcodes returns the removed ids of userrefcodes.
func (m *UserMutation) RemovedUserrefcodesIDs() (ids []int) {
	for id := range m.removeduserrefcodes {
		ids = append(ids, id)
	}
	return
}

// UserrefcodesIDs returns the userrefcodes ids in the mutation.
func (m *UserMutation) UserrefcodesIDs() (ids []int) {
	for id := range m.userrefcodes {
		ids = append(ids, id)
	}
	return
}

// ResetUserrefcodes reset all changes of the "userrefcodes" edge.
func (m *UserMutation) ResetUserrefcodes() {
	m.userrefcodes = nil
	m.removeduserrefcodes = nil
}

// SetInquiryID sets the inquiry edge to Inquiry by id.
func (m *UserMutation) SetInquiryID(id int) {
	m.inquiry = &id
}

// ClearInquiry clears the inquiry edge to Inquiry.
func (m *UserMutation) ClearInquiry() {
	m.clearedinquiry = true
}

// InquiryCleared returns if the edge inquiry was cleared.
func (m *UserMutation) InquiryCleared() bool {
	return m.clearedinquiry
}

// InquiryID returns the inquiry id in the mutation.
func (m *UserMutation) InquiryID() (id int, exists bool) {
	if m.inquiry != nil {
		return *m.inquiry, true
	}
	return
}

// InquiryIDs returns the inquiry ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// InquiryID instead. It exists only for internal usage by the builders.
func (m *UserMutation) InquiryIDs() (ids []int) {
	if id := m.inquiry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInquiry reset all changes of the "inquiry" edge.
func (m *UserMutation) ResetInquiry() {
	m.inquiry = nil
	m.clearedinquiry = false
}

// AddServiceCustomerIDs adds the service_customer edge to Service by ids.
func (m *UserMutation) AddServiceCustomerIDs(ids ...int) {
	if m.service_customer == nil {
		m.service_customer = make(map[int]struct{})
	}
	for i := range ids {
		m.service_customer[ids[i]] = struct{}{}
	}
}

// RemoveServiceCustomerIDs removes the service_customer edge to Service by ids.
func (m *UserMutation) RemoveServiceCustomerIDs(ids ...int) {
	if m.removedservice_customer == nil {
		m.removedservice_customer = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservice_customer[ids[i]] = struct{}{}
	}
}

// RemovedServiceCustomer returns the removed ids of service_customer.
func (m *UserMutation) RemovedServiceCustomerIDs() (ids []int) {
	for id := range m.removedservice_customer {
		ids = append(ids, id)
	}
	return
}

// ServiceCustomerIDs returns the service_customer ids in the mutation.
func (m *UserMutation) ServiceCustomerIDs() (ids []int) {
	for id := range m.service_customer {
		ids = append(ids, id)
	}
	return
}

// ResetServiceCustomer reset all changes of the "service_customer" edge.
func (m *UserMutation) ResetServiceCustomer() {
	m.service_customer = nil
	m.removedservice_customer = nil
}

// AddServiceProviderIDs adds the service_provider edge to Service by ids.
func (m *UserMutation) AddServiceProviderIDs(ids ...int) {
	if m.service_provider == nil {
		m.service_provider = make(map[int]struct{})
	}
	for i := range ids {
		m.service_provider[ids[i]] = struct{}{}
	}
}

// RemoveServiceProviderIDs removes the service_provider edge to Service by ids.
func (m *UserMutation) RemoveServiceProviderIDs(ids ...int) {
	if m.removedservice_provider == nil {
		m.removedservice_provider = make(map[int]struct{})
	}
	for i := range ids {
		m.removedservice_provider[ids[i]] = struct{}{}
	}
}

// RemovedServiceProvider returns the removed ids of service_provider.
func (m *UserMutation) RemovedServiceProviderIDs() (ids []int) {
	for id := range m.removedservice_provider {
		ids = append(ids, id)
	}
	return
}

// ServiceProviderIDs returns the service_provider ids in the mutation.
func (m *UserMutation) ServiceProviderIDs() (ids []int) {
	for id := range m.service_provider {
		ids = append(ids, id)
	}
	return
}

// ResetServiceProvider reset all changes of the "service_provider" edge.
func (m *UserMutation) ResetServiceProvider() {
	m.service_provider = nil
	m.removedservice_provider = nil
}

// AddGroupIDs adds the groups edge to Group by ids.
func (m *UserMutation) AddGroupIDs(ids ...int) {
	if m.groups == nil {
		m.groups = make(map[int]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// RemoveGroupIDs removes the groups edge to Group by ids.
func (m *UserMutation) RemoveGroupIDs(ids ...int) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int]struct{})
	}
	for i := range ids {
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed ids of groups.
func (m *UserMutation) RemovedGroupsIDs() (ids []int) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the groups ids in the mutation.
func (m *UserMutation) GroupsIDs() (ids []int) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups reset all changes of the "groups" edge.
func (m *UserMutation) ResetGroups() {
	m.groups = nil
	m.removedgroups = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.phone_verified != nil {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.auth_sms_code != nil {
		fields = append(fields, user.FieldAuthSmsCode)
	}
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.premium_kind != nil {
		fields = append(fields, user.FieldPremiumKind)
	}
	if m.premium_expiry_date != nil {
		fields = append(fields, user.FieldPremiumExpiryDate)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPhoneVerified:
		return m.PhoneVerified()
	case user.FieldAuthSmsCode:
		return m.AuthSmsCode()
	case user.FieldGender:
		return m.Gender()
	case user.FieldPremiumKind:
		return m.PremiumKind()
	case user.FieldPremiumExpiryDate:
		return m.PremiumExpiryDate()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case user.FieldAuthSmsCode:
		return m.OldAuthSmsCode(ctx)
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldPremiumKind:
		return m.OldPremiumKind(ctx)
	case user.FieldPremiumExpiryDate:
		return m.OldPremiumExpiryDate(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case user.FieldAuthSmsCode:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthSmsCode(v)
		return nil
	case user.FieldGender:
		v, ok := value.(user.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldPremiumKind:
		v, ok := value.(user.PremiumKind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPremiumKind(v)
		return nil
	case user.FieldPremiumExpiryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPremiumExpiryDate(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addauth_sms_code != nil {
		fields = append(fields, user.FieldAuthSmsCode)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAuthSmsCode:
		return m.AddedAuthSmsCode()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldAuthSmsCode:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthSmsCode(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAuthSmsCode) {
		fields = append(fields, user.FieldAuthSmsCode)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAuthSmsCode:
		m.ClearAuthSmsCode()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case user.FieldAuthSmsCode:
		m.ResetAuthSmsCode()
		return nil
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldPremiumKind:
		m.ResetPremiumKind()
		return nil
	case user.FieldPremiumExpiryDate:
		m.ResetPremiumExpiryDate()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.refcode_invitor != nil {
		edges = append(edges, user.EdgeRefcodeInvitor)
	}
	if m.userrefcodes != nil {
		edges = append(edges, user.EdgeUserrefcodes)
	}
	if m.inquiry != nil {
		edges = append(edges, user.EdgeInquiry)
	}
	if m.service_customer != nil {
		edges = append(edges, user.EdgeServiceCustomer)
	}
	if m.service_provider != nil {
		edges = append(edges, user.EdgeServiceProvider)
	}
	if m.groups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRefcodeInvitor:
		ids := make([]ent.Value, 0, len(m.refcode_invitor))
		for id := range m.refcode_invitor {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserrefcodes:
		ids := make([]ent.Value, 0, len(m.userrefcodes))
		for id := range m.userrefcodes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInquiry:
		if id := m.inquiry; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeServiceCustomer:
		ids := make([]ent.Value, 0, len(m.service_customer))
		for id := range m.service_customer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeServiceProvider:
		ids := make([]ent.Value, 0, len(m.service_provider))
		for id := range m.service_provider {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedrefcode_invitor != nil {
		edges = append(edges, user.EdgeRefcodeInvitor)
	}
	if m.removeduserrefcodes != nil {
		edges = append(edges, user.EdgeUserrefcodes)
	}
	if m.removedservice_customer != nil {
		edges = append(edges, user.EdgeServiceCustomer)
	}
	if m.removedservice_provider != nil {
		edges = append(edges, user.EdgeServiceProvider)
	}
	if m.removedgroups != nil {
		edges = append(edges, user.EdgeGroups)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRefcodeInvitor:
		ids := make([]ent.Value, 0, len(m.removedrefcode_invitor))
		for id := range m.removedrefcode_invitor {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserrefcodes:
		ids := make([]ent.Value, 0, len(m.removeduserrefcodes))
		for id := range m.removeduserrefcodes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeServiceCustomer:
		ids := make([]ent.Value, 0, len(m.removedservice_customer))
		for id := range m.removedservice_customer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeServiceProvider:
		ids := make([]ent.Value, 0, len(m.removedservice_provider))
		for id := range m.removedservice_provider {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedinquiry {
		edges = append(edges, user.EdgeInquiry)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeInquiry:
		return m.clearedinquiry
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeInquiry:
		m.ClearInquiry()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRefcodeInvitor:
		m.ResetRefcodeInvitor()
		return nil
	case user.EdgeUserrefcodes:
		m.ResetUserrefcodes()
		return nil
	case user.EdgeInquiry:
		m.ResetInquiry()
		return nil
	case user.EdgeServiceCustomer:
		m.ResetServiceCustomer()
		return nil
	case user.EdgeServiceProvider:
		m.ResetServiceProvider()
		return nil
	case user.EdgeGroups:
		m.ResetGroups()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserRefCodesMutation represents an operation that mutate the UserRefCodesSlice
// nodes in the graph.
type UserRefCodesMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	ref_code               *string
	ref_code_type          *userrefcodes.RefCodeType
	clearedFields          map[string]struct{}
	users                  *int
	clearedusers           bool
	refcode_invitee        *int
	clearedrefcode_invitee bool
	done                   bool
	oldValue               func(context.Context) (*UserRefCodes, error)
}

var _ ent.Mutation = (*UserRefCodesMutation)(nil)

// userrefcodesOption allows to manage the mutation configuration using functional options.
type userrefcodesOption func(*UserRefCodesMutation)

// newUserRefCodesMutation creates new mutation for $n.Name.
func newUserRefCodesMutation(c config, op Op, opts ...userrefcodesOption) *UserRefCodesMutation {
	m := &UserRefCodesMutation{
		config:        c,
		op:            op,
		typ:           TypeUserRefCodes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserRefCodesID sets the id field of the mutation.
func withUserRefCodesID(id int) userrefcodesOption {
	return func(m *UserRefCodesMutation) {
		var (
			err   error
			once  sync.Once
			value *UserRefCodes
		)
		m.oldValue = func(ctx context.Context) (*UserRefCodes, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserRefCodes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserRefCodes sets the old UserRefCodes of the mutation.
func withUserRefCodes(node *UserRefCodes) userrefcodesOption {
	return func(m *UserRefCodesMutation) {
		m.oldValue = func(context.Context) (*UserRefCodes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserRefCodesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserRefCodesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserRefCodesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRefCode sets the ref_code field.
func (m *UserRefCodesMutation) SetRefCode(s string) {
	m.ref_code = &s
}

// RefCode returns the ref_code value in the mutation.
func (m *UserRefCodesMutation) RefCode() (r string, exists bool) {
	v := m.ref_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRefCode returns the old ref_code value of the UserRefCodes.
// If the UserRefCodes object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRefCodesMutation) OldRefCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRefCode is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRefCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefCode: %w", err)
	}
	return oldValue.RefCode, nil
}

// ResetRefCode reset all changes of the "ref_code" field.
func (m *UserRefCodesMutation) ResetRefCode() {
	m.ref_code = nil
}

// SetRefCodeType sets the ref_code_type field.
func (m *UserRefCodesMutation) SetRefCodeType(uct userrefcodes.RefCodeType) {
	m.ref_code_type = &uct
}

// RefCodeType returns the ref_code_type value in the mutation.
func (m *UserRefCodesMutation) RefCodeType() (r userrefcodes.RefCodeType, exists bool) {
	v := m.ref_code_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRefCodeType returns the old ref_code_type value of the UserRefCodes.
// If the UserRefCodes object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserRefCodesMutation) OldRefCodeType(ctx context.Context) (v userrefcodes.RefCodeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRefCodeType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRefCodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefCodeType: %w", err)
	}
	return oldValue.RefCodeType, nil
}

// ResetRefCodeType reset all changes of the "ref_code_type" field.
func (m *UserRefCodesMutation) ResetRefCodeType() {
	m.ref_code_type = nil
}

// SetUsersID sets the users edge to User by id.
func (m *UserRefCodesMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the users edge to User.
func (m *UserRefCodesMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared returns if the edge users was cleared.
func (m *UserRefCodesMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the users id in the mutation.
func (m *UserRefCodesMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the users ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *UserRefCodesMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers reset all changes of the "users" edge.
func (m *UserRefCodesMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// SetRefcodeInviteeID sets the refcode_invitee edge to User by id.
func (m *UserRefCodesMutation) SetRefcodeInviteeID(id int) {
	m.refcode_invitee = &id
}

// ClearRefcodeInvitee clears the refcode_invitee edge to User.
func (m *UserRefCodesMutation) ClearRefcodeInvitee() {
	m.clearedrefcode_invitee = true
}

// RefcodeInviteeCleared returns if the edge refcode_invitee was cleared.
func (m *UserRefCodesMutation) RefcodeInviteeCleared() bool {
	return m.clearedrefcode_invitee
}

// RefcodeInviteeID returns the refcode_invitee id in the mutation.
func (m *UserRefCodesMutation) RefcodeInviteeID() (id int, exists bool) {
	if m.refcode_invitee != nil {
		return *m.refcode_invitee, true
	}
	return
}

// RefcodeInviteeIDs returns the refcode_invitee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RefcodeInviteeID instead. It exists only for internal usage by the builders.
func (m *UserRefCodesMutation) RefcodeInviteeIDs() (ids []int) {
	if id := m.refcode_invitee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRefcodeInvitee reset all changes of the "refcode_invitee" edge.
func (m *UserRefCodesMutation) ResetRefcodeInvitee() {
	m.refcode_invitee = nil
	m.clearedrefcode_invitee = false
}

// Op returns the operation name.
func (m *UserRefCodesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserRefCodes).
func (m *UserRefCodesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserRefCodesMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.ref_code != nil {
		fields = append(fields, userrefcodes.FieldRefCode)
	}
	if m.ref_code_type != nil {
		fields = append(fields, userrefcodes.FieldRefCodeType)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserRefCodesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userrefcodes.FieldRefCode:
		return m.RefCode()
	case userrefcodes.FieldRefCodeType:
		return m.RefCodeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserRefCodesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userrefcodes.FieldRefCode:
		return m.OldRefCode(ctx)
	case userrefcodes.FieldRefCodeType:
		return m.OldRefCodeType(ctx)
	}
	return nil, fmt.Errorf("unknown UserRefCodes field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserRefCodesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userrefcodes.FieldRefCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefCode(v)
		return nil
	case userrefcodes.FieldRefCodeType:
		v, ok := value.(userrefcodes.RefCodeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefCodeType(v)
		return nil
	}
	return fmt.Errorf("unknown UserRefCodes field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserRefCodesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserRefCodesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserRefCodesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserRefCodes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserRefCodesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserRefCodesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserRefCodesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserRefCodes nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserRefCodesMutation) ResetField(name string) error {
	switch name {
	case userrefcodes.FieldRefCode:
		m.ResetRefCode()
		return nil
	case userrefcodes.FieldRefCodeType:
		m.ResetRefCodeType()
		return nil
	}
	return fmt.Errorf("unknown UserRefCodes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserRefCodesMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, userrefcodes.EdgeUsers)
	}
	if m.refcode_invitee != nil {
		edges = append(edges, userrefcodes.EdgeRefcodeInvitee)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserRefCodesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userrefcodes.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	case userrefcodes.EdgeRefcodeInvitee:
		if id := m.refcode_invitee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserRefCodesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserRefCodesMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserRefCodesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, userrefcodes.EdgeUsers)
	}
	if m.clearedrefcode_invitee {
		edges = append(edges, userrefcodes.EdgeRefcodeInvitee)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserRefCodesMutation) EdgeCleared(name string) bool {
	switch name {
	case userrefcodes.EdgeUsers:
		return m.clearedusers
	case userrefcodes.EdgeRefcodeInvitee:
		return m.clearedrefcode_invitee
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserRefCodesMutation) ClearEdge(name string) error {
	switch name {
	case userrefcodes.EdgeUsers:
		m.ClearUsers()
		return nil
	case userrefcodes.EdgeRefcodeInvitee:
		m.ClearRefcodeInvitee()
		return nil
	}
	return fmt.Errorf("unknown UserRefCodes unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserRefCodesMutation) ResetEdge(name string) error {
	switch name {
	case userrefcodes.EdgeUsers:
		m.ResetUsers()
		return nil
	case userrefcodes.EdgeRefcodeInvitee:
		m.ResetRefcodeInvitee()
		return nil
	}
	return fmt.Errorf("unknown UserRefCodes edge %s", name)
}
