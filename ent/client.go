// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/huangc28/go-darkpanda-backend/ent/migrate"

	"github.com/huangc28/go-darkpanda-backend/ent/group"
	"github.com/huangc28/go-darkpanda-backend/ent/groupusers"
	"github.com/huangc28/go-darkpanda-backend/ent/inquiry"
	"github.com/huangc28/go-darkpanda-backend/ent/service"
	"github.com/huangc28/go-darkpanda-backend/ent/user"
	"github.com/huangc28/go-darkpanda-backend/ent/userrefcodes"

	"github.com/facebookincubator/ent/dialect"
	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/facebookincubator/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// GroupUsers is the client for interacting with the GroupUsers builders.
	GroupUsers *GroupUsersClient
	// Inquiry is the client for interacting with the Inquiry builders.
	Inquiry *InquiryClient
	// Service is the client for interacting with the Service builders.
	Service *ServiceClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserRefCodes is the client for interacting with the UserRefCodes builders.
	UserRefCodes *UserRefCodesClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Group = NewGroupClient(c.config)
	c.GroupUsers = NewGroupUsersClient(c.config)
	c.Inquiry = NewInquiryClient(c.config)
	c.Service = NewServiceClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserRefCodes = NewUserRefCodesClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: tx, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Group:        NewGroupClient(cfg),
		GroupUsers:   NewGroupUsersClient(cfg),
		Inquiry:      NewInquiryClient(cfg),
		Service:      NewServiceClient(cfg),
		User:         NewUserClient(cfg),
		UserRefCodes: NewUserRefCodesClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(*sql.Driver).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := config{driver: &txDriver{tx: tx, drv: c.driver}, log: c.log, debug: c.debug, hooks: c.hooks}
	return &Tx{
		config:       cfg,
		Group:        NewGroupClient(cfg),
		GroupUsers:   NewGroupUsersClient(cfg),
		Inquiry:      NewInquiryClient(cfg),
		Service:      NewServiceClient(cfg),
		User:         NewUserClient(cfg),
		UserRefCodes: NewUserRefCodesClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Group.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := config{driver: dialect.Debug(c.driver, c.log), log: c.log, debug: true, hooks: c.hooks}
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Group.Use(hooks...)
	c.GroupUsers.Use(hooks...)
	c.Inquiry.Use(hooks...)
	c.Service.Use(hooks...)
	c.User.Use(hooks...)
	c.UserRefCodes.Use(hooks...)
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Create returns a create builder for Group.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(gr *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(gr))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id int) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GroupClient) DeleteOne(gr *Group) *GroupDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GroupClient) DeleteOneID(id int) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{config: c.config}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id int) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id int) *Group {
	gr, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return gr
}

// QueryUsers queries the users edge of a Group.
func (c *GroupClient) QueryUsers(gr *Group) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, group.UsersTable, group.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	return c.hooks.Group
}

// GroupUsersClient is a client for the GroupUsers schema.
type GroupUsersClient struct {
	config
}

// NewGroupUsersClient returns a client for the GroupUsers from the given config.
func NewGroupUsersClient(c config) *GroupUsersClient {
	return &GroupUsersClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `groupusers.Hooks(f(g(h())))`.
func (c *GroupUsersClient) Use(hooks ...Hook) {
	c.hooks.GroupUsers = append(c.hooks.GroupUsers, hooks...)
}

// Create returns a create builder for GroupUsers.
func (c *GroupUsersClient) Create() *GroupUsersCreate {
	mutation := newGroupUsersMutation(c.config, OpCreate)
	return &GroupUsersCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of GroupUsers entities.
func (c *GroupUsersClient) CreateBulk(builders ...*GroupUsersCreate) *GroupUsersCreateBulk {
	return &GroupUsersCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GroupUsers.
func (c *GroupUsersClient) Update() *GroupUsersUpdate {
	mutation := newGroupUsersMutation(c.config, OpUpdate)
	return &GroupUsersUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupUsersClient) UpdateOne(gu *GroupUsers) *GroupUsersUpdateOne {
	mutation := newGroupUsersMutation(c.config, OpUpdateOne, withGroupUsers(gu))
	return &GroupUsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupUsersClient) UpdateOneID(id int) *GroupUsersUpdateOne {
	mutation := newGroupUsersMutation(c.config, OpUpdateOne, withGroupUsersID(id))
	return &GroupUsersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GroupUsers.
func (c *GroupUsersClient) Delete() *GroupUsersDelete {
	mutation := newGroupUsersMutation(c.config, OpDelete)
	return &GroupUsersDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GroupUsersClient) DeleteOne(gu *GroupUsers) *GroupUsersDeleteOne {
	return c.DeleteOneID(gu.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GroupUsersClient) DeleteOneID(id int) *GroupUsersDeleteOne {
	builder := c.Delete().Where(groupusers.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupUsersDeleteOne{builder}
}

// Query returns a query builder for GroupUsers.
func (c *GroupUsersClient) Query() *GroupUsersQuery {
	return &GroupUsersQuery{config: c.config}
}

// Get returns a GroupUsers entity by its id.
func (c *GroupUsersClient) Get(ctx context.Context, id int) (*GroupUsers, error) {
	return c.Query().Where(groupusers.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupUsersClient) GetX(ctx context.Context, id int) *GroupUsers {
	gu, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return gu
}

// Hooks returns the client hooks.
func (c *GroupUsersClient) Hooks() []Hook {
	return c.hooks.GroupUsers
}

// InquiryClient is a client for the Inquiry schema.
type InquiryClient struct {
	config
}

// NewInquiryClient returns a client for the Inquiry from the given config.
func NewInquiryClient(c config) *InquiryClient {
	return &InquiryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inquiry.Hooks(f(g(h())))`.
func (c *InquiryClient) Use(hooks ...Hook) {
	c.hooks.Inquiry = append(c.hooks.Inquiry, hooks...)
}

// Create returns a create builder for Inquiry.
func (c *InquiryClient) Create() *InquiryCreate {
	mutation := newInquiryMutation(c.config, OpCreate)
	return &InquiryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Inquiry entities.
func (c *InquiryClient) CreateBulk(builders ...*InquiryCreate) *InquiryCreateBulk {
	return &InquiryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Inquiry.
func (c *InquiryClient) Update() *InquiryUpdate {
	mutation := newInquiryMutation(c.config, OpUpdate)
	return &InquiryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InquiryClient) UpdateOne(i *Inquiry) *InquiryUpdateOne {
	mutation := newInquiryMutation(c.config, OpUpdateOne, withInquiry(i))
	return &InquiryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InquiryClient) UpdateOneID(id int) *InquiryUpdateOne {
	mutation := newInquiryMutation(c.config, OpUpdateOne, withInquiryID(id))
	return &InquiryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Inquiry.
func (c *InquiryClient) Delete() *InquiryDelete {
	mutation := newInquiryMutation(c.config, OpDelete)
	return &InquiryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InquiryClient) DeleteOne(i *Inquiry) *InquiryDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InquiryClient) DeleteOneID(id int) *InquiryDeleteOne {
	builder := c.Delete().Where(inquiry.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InquiryDeleteOne{builder}
}

// Query returns a query builder for Inquiry.
func (c *InquiryClient) Query() *InquiryQuery {
	return &InquiryQuery{config: c.config}
}

// Get returns a Inquiry entity by its id.
func (c *InquiryClient) Get(ctx context.Context, id int) (*Inquiry, error) {
	return c.Query().Where(inquiry.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InquiryClient) GetX(ctx context.Context, id int) *Inquiry {
	i, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return i
}

// QueryUsers queries the users edge of a Inquiry.
func (c *InquiryClient) QueryUsers(i *Inquiry) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inquiry.Table, inquiry.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, inquiry.UsersTable, inquiry.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InquiryClient) Hooks() []Hook {
	return c.hooks.Inquiry
}

// ServiceClient is a client for the Service schema.
type ServiceClient struct {
	config
}

// NewServiceClient returns a client for the Service from the given config.
func NewServiceClient(c config) *ServiceClient {
	return &ServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `service.Hooks(f(g(h())))`.
func (c *ServiceClient) Use(hooks ...Hook) {
	c.hooks.Service = append(c.hooks.Service, hooks...)
}

// Create returns a create builder for Service.
func (c *ServiceClient) Create() *ServiceCreate {
	mutation := newServiceMutation(c.config, OpCreate)
	return &ServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of Service entities.
func (c *ServiceClient) CreateBulk(builders ...*ServiceCreate) *ServiceCreateBulk {
	return &ServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Service.
func (c *ServiceClient) Update() *ServiceUpdate {
	mutation := newServiceMutation(c.config, OpUpdate)
	return &ServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServiceClient) UpdateOne(s *Service) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withService(s))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServiceClient) UpdateOneID(id int) *ServiceUpdateOne {
	mutation := newServiceMutation(c.config, OpUpdateOne, withServiceID(id))
	return &ServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Service.
func (c *ServiceClient) Delete() *ServiceDelete {
	mutation := newServiceMutation(c.config, OpDelete)
	return &ServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ServiceClient) DeleteOne(s *Service) *ServiceDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ServiceClient) DeleteOneID(id int) *ServiceDeleteOne {
	builder := c.Delete().Where(service.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServiceDeleteOne{builder}
}

// Query returns a query builder for Service.
func (c *ServiceClient) Query() *ServiceQuery {
	return &ServiceQuery{config: c.config}
}

// Get returns a Service entity by its id.
func (c *ServiceClient) Get(ctx context.Context, id int) (*Service, error) {
	return c.Query().Where(service.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServiceClient) GetX(ctx context.Context, id int) *Service {
	s, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return s
}

// QueryCustomer queries the customer edge of a Service.
func (c *ServiceClient) QueryCustomer(s *Service) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, service.CustomerTable, service.CustomerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceProvider queries the service_provider edge of a Service.
func (c *ServiceClient) QueryServiceProvider(s *Service) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(service.Table, service.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, service.ServiceProviderTable, service.ServiceProviderColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServiceClient) Hooks() []Hook {
	return c.hooks.Service
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{config: c.config}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	u, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return u
}

// QueryRefcodeInvitor queries the refcode_invitor edge of a User.
func (c *UserClient) QueryRefcodeInvitor(u *User) *UserRefCodesQuery {
	query := &UserRefCodesQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrefcodes.Table, userrefcodes.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.RefcodeInvitorTable, user.RefcodeInvitorColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserrefcodes queries the userrefcodes edge of a User.
func (c *UserClient) QueryUserrefcodes(u *User) *UserRefCodesQuery {
	query := &UserRefCodesQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userrefcodes.Table, userrefcodes.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.UserrefcodesTable, user.UserrefcodesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInquiry queries the inquiry edge of a User.
func (c *UserClient) QueryInquiry(u *User) *InquiryQuery {
	query := &InquiryQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(inquiry.Table, inquiry.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.InquiryTable, user.InquiryColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceCustomer queries the service_customer edge of a User.
func (c *UserClient) QueryServiceCustomer(u *User) *ServiceQuery {
	query := &ServiceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ServiceCustomerTable, user.ServiceCustomerColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServiceProvider queries the service_provider edge of a User.
func (c *UserClient) QueryServiceProvider(u *User) *ServiceQuery {
	query := &ServiceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(service.Table, service.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ServiceProviderTable, user.ServiceProviderColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a User.
func (c *UserClient) QueryGroups(u *User) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.GroupsTable, user.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// UserRefCodesClient is a client for the UserRefCodes schema.
type UserRefCodesClient struct {
	config
}

// NewUserRefCodesClient returns a client for the UserRefCodes from the given config.
func NewUserRefCodesClient(c config) *UserRefCodesClient {
	return &UserRefCodesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userrefcodes.Hooks(f(g(h())))`.
func (c *UserRefCodesClient) Use(hooks ...Hook) {
	c.hooks.UserRefCodes = append(c.hooks.UserRefCodes, hooks...)
}

// Create returns a create builder for UserRefCodes.
func (c *UserRefCodesClient) Create() *UserRefCodesCreate {
	mutation := newUserRefCodesMutation(c.config, OpCreate)
	return &UserRefCodesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// BulkCreate returns a builder for creating a bulk of UserRefCodes entities.
func (c *UserRefCodesClient) CreateBulk(builders ...*UserRefCodesCreate) *UserRefCodesCreateBulk {
	return &UserRefCodesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserRefCodes.
func (c *UserRefCodesClient) Update() *UserRefCodesUpdate {
	mutation := newUserRefCodesMutation(c.config, OpUpdate)
	return &UserRefCodesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserRefCodesClient) UpdateOne(urc *UserRefCodes) *UserRefCodesUpdateOne {
	mutation := newUserRefCodesMutation(c.config, OpUpdateOne, withUserRefCodes(urc))
	return &UserRefCodesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserRefCodesClient) UpdateOneID(id int) *UserRefCodesUpdateOne {
	mutation := newUserRefCodesMutation(c.config, OpUpdateOne, withUserRefCodesID(id))
	return &UserRefCodesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserRefCodes.
func (c *UserRefCodesClient) Delete() *UserRefCodesDelete {
	mutation := newUserRefCodesMutation(c.config, OpDelete)
	return &UserRefCodesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserRefCodesClient) DeleteOne(urc *UserRefCodes) *UserRefCodesDeleteOne {
	return c.DeleteOneID(urc.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserRefCodesClient) DeleteOneID(id int) *UserRefCodesDeleteOne {
	builder := c.Delete().Where(userrefcodes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserRefCodesDeleteOne{builder}
}

// Query returns a query builder for UserRefCodes.
func (c *UserRefCodesClient) Query() *UserRefCodesQuery {
	return &UserRefCodesQuery{config: c.config}
}

// Get returns a UserRefCodes entity by its id.
func (c *UserRefCodesClient) Get(ctx context.Context, id int) (*UserRefCodes, error) {
	return c.Query().Where(userrefcodes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserRefCodesClient) GetX(ctx context.Context, id int) *UserRefCodes {
	urc, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return urc
}

// QueryUsers queries the users edge of a UserRefCodes.
func (c *UserRefCodesClient) QueryUsers(urc *UserRefCodes) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := urc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrefcodes.Table, userrefcodes.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userrefcodes.UsersTable, userrefcodes.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(urc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRefcodeInvitee queries the refcode_invitee edge of a UserRefCodes.
func (c *UserRefCodesClient) QueryRefcodeInvitee(urc *UserRefCodes) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := urc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userrefcodes.Table, userrefcodes.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, userrefcodes.RefcodeInviteeTable, userrefcodes.RefcodeInviteeColumn),
		)
		fromV = sqlgraph.Neighbors(urc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserRefCodesClient) Hooks() []Hook {
	return c.hooks.UserRefCodes
}
